# 4-排序

##### 如何分析一个“排序算法”？

- 排序算法的执行效率
  - 1.最好情况、最坏情况、平均情况时间复杂度
  - 2.时间复杂度的系数、常数 、低阶
  - 3.比较次数和交换（或移动）次数

- 排序算法的内存消耗：考虑是否是原地排序，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

- 排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

**简单介绍了解：**逆序度 = 满有序度 - 有序度

冒泡排序、插入排序 都是稳定排序。

选择排序是不稳定排序，会打乱原来相等元素的位置关系。

##### 为什么实际多选用插入排序？

前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。

插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：
```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
  int tmp = a[j];
  a[j] = a[j+1];
  a[j+1] = tmp;
  flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j]; // 数据移动
  } else { break;}
```
我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。


##### O(n^2)时间复杂度排序-附图
![栈](/BeautyOfAlgorithmDataStructures/Resources/4-Sort-01.png)

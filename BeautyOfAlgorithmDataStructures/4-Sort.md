# 4-排序

##### 如何分析一个“排序算法”？

- 排序算法的执行效率
  - 1.最好情况、最坏情况、平均情况时间复杂度
  - 2.时间复杂度的系数、常数 、低阶
  - 3.比较次数和交换（或移动）次数

- 排序算法的内存消耗：考虑是否是原地排序，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

- 排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

**简单介绍了解：**逆序度 = 满有序度 - 有序度

冒泡排序、插入排序 都是稳定排序。

选择排序是不稳定排序，会打乱原来相等元素的位置关系。

##### 为什么实际多选用插入排序？

前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。

插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：
```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
  int tmp = a[j];
  a[j] = a[j+1];
  a[j+1] = tmp;
  flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j]; // 数据移动
} else { break;}
```
我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。


##### O(n^2)时间复杂度排序-附图
![排序](/BeautyOfAlgorithmDataStructures/Resources/4-Sort-01.png)


##### 归并排序和快速排序
归并排序和快速排序都用到了分治思想。

分治算法一般都是用递归来实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。

**递归排序**时间复杂度是O(nlogn)，空间复杂度是O(n)。

归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。

**快速排序**是不稳定，但是原地排序的排序算法。

**快速排序的分区：**
```
partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
      }
  }
  swap A[i] with A[r] //此时i已经到达大于pivot的位置，交换，把pivot放到中间。
  return i
```

##### O(n) 时间复杂度内求无序数组中的第 K 大元素。

如果 p+1=K，那 A[p] 就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1] 区间查找。

第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1，时间复杂度就为 O(n)。

**解法二 - 时间复杂度不满足**
每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？不过，时间复杂度就并不是 O(n) 了，而是 O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n) 不就等于 O(n) 吗？这个可不能这么简单地划等号。当 K 是比较小的常量时，比如 1、2，那最好时间复杂度确实是 O(n)；但当 K 等于 n/2 或者 n 时，这种最坏情况下的时间复杂度就是 O(n2) 了。

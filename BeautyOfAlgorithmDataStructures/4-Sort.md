# 4-排序

##### 如何分析一个“排序算法”？

- 排序算法的执行效率
  - 1.最好情况、最坏情况、平均情况时间复杂度
  - 2.时间复杂度的系数、常数 、低阶
  - 3.比较次数和交换（或移动）次数

- 排序算法的内存消耗：考虑是否是原地排序，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

- 排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

**简单介绍了解：** 逆序度 = 满有序度 - 有序度

冒泡排序、插入排序 都是稳定排序。

选择排序是不稳定排序，会打乱原来相等元素的位置关系。

##### 为什么实际多选用插入排序？

前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。

插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：
```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
  int tmp = a[j];
  a[j] = a[j+1];
  a[j+1] = tmp;
  flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j]; // 数据移动
} else { break;}
```
我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。


##### O(n^2)时间复杂度排序-附图
![排序](/BeautyOfAlgorithmDataStructures/Resources/4-Sort-01.png)


##### 归并排序和快速排序
归并排序和快速排序都用到了分治思想。

分治算法一般都是用递归来实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。

**递归排序**时间复杂度是O(nlogn)，空间复杂度是O(n)。

归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。

**快速排序**是不稳定，但是原地排序的排序算法。

**快速排序的分区：**
```
partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
      }
  }
  swap A[i] with A[r] //此时i已经到达大于pivot的位置，交换，把pivot放到中间。
  return i
```

##### O(n) 时间复杂度内求无序数组中的第 K 大元素。

如果 p+1=K，那 A[p] 就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1] 区间查找。

第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1，时间复杂度就为 O(n)。

**解法二 - 时间复杂度不满足**
每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？不过，时间复杂度就并不是 O(n) 了，而是 O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n) 不就等于 O(n) 吗？这个可不能这么简单地划等号。当 K 是比较小的常量时，比如 1、2，那最好时间复杂度确实是 O(n)；但当 K 等于 n/2 或者 n 时，这种最坏情况下的时间复杂度就是 O(n2) 了。


##### 桶排序、计数排序、基数排序

**桶排序**（Bucket sort）

比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

> 注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。

**计数排序**（Counting sort）

1.算法原理
- 1计数其实就是桶排序的一种特殊情况。
- 2当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶
- 3每个桶内的数据值都是相同的，就省掉了桶内排序的时间。
2.代码实现（参见下一条留言）

**案例分析：假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。**

使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。
C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。
对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。

数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？
从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。从后向前可以保证稳定性。

以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。

3.使用条件 **重要**

> 只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。

> 总结：桶排序和计数排序对于数据跨度太大，都会显得力不从心。

**基数排序**（Radix sort）

对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

##### 实现快速的排序

Glibc 中的 qsort() 函数：

数量级小的时候，使用归并排序。

数量级较大的时候，使用快速排序，三点取中发划分区间。

在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序。

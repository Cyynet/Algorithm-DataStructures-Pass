# 1-数组和链表

### 线性表

![线性表](/Resources/1-Array-LinkedList-beauty-01.png)

> 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据，除了数组，链表、队列、栈等也是线性表结构。

> 链表（LinkedList）也是一种线性表的数据结构，它无需连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

> “链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。
> 数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。

##### 单链表

头结点：头结点用来记录链表的基地址。

尾节点：尾节点的指针不是指向下一个结点，而是指向一个空地址 NULL。

##### 双链表

一个普通节点，既有前驱又有后继。

链表的话，删除和插入的操作仅对于当前元素的操作是O(1)，但是实际擦操作，对于单链表为了找前驱确实O(n)，而双链表无须找前驱时间复杂度是O(1)。

##### 环形链表

### 非线性表

![非线性表](/Resources/1-Array-LinkedList-beauty-02.png)

### 低效的插入和删除

- 插入，把被插入位置的元素挪到后面
- 删除，把被删除位置的元素标记为删除，待特殊情况后进行删除操作。

> 如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？
> 没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

### 为什么数据下表从0开始

下标最确切的定义应该是  偏移offset，a[0]代表的是偏移为0的位置。

### LRU淘汰算法
> 常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

**如何用链表来实现 LRU 缓存淘汰策略呢？**

我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

- 1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
- 2.如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
- 3.缓存访问的时间复杂度为 O(n)。

实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。后面讲。

### 轻松写链表的算法

> 1.分别是理解指针或引用的含义、2.警惕指针丢失和内存泄漏、3.利用哨兵简化实现难度、4.重点留意边界条件处理，5.以及举例画图、辅助思考，6.还有多写多练。

**精选了5个常见的链表操作**

这几个操作都能写熟练，不熟就多写几遍，保证你之后再也不会害怕写链表代码。

`单链表反转、链表中环的检测、两个有序的链表合并、删除链表倒数第 n 个结点、求链表的中间结点。`

**我经常用来检查链表代码是否正确的边界条件有这样几个：**
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

**写链表代码是最考验逻辑思维能力的**。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。

所以，这也是很多面试官喜欢让人手写链表代码的原因，要多练。

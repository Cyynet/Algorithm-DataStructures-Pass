# 递归和分治

**递归**：递归终止条件是必须的，否则死递归。

**递归模板：**

![](/Resources/7-递归和分治-1.png)

**分治（Divide and Conquer）**:用于解决无中间态、重复计算，不然类似递归，效率并不高。

**分治模板**
![](/Resources/7-递归和分治-2.png)
## Leetcode真题

**98-Pow(x, n)-Medium**

**解题：**
> 明确题目

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

> 所有可能解法

  - 暴利，傻乘，O(n)
  - 分治，二分法，O(logn)

> CODINNG

*解法一*

```
/**
  分治
*/
class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
        //terminator
        if n == 0  {
            return 1
        }

        //prepare data
        if n < 0 {
            return myPow(1 / x, -n)
        }

        if n % 2 == 1{
            return x * myPow(x, n-1)
        }

        //divide and conquer, generate final result
        return myPow(x * x, n / 2)
    }
}
```
*解法二*

```
/**
  分治
*/
class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
        var pow: Double = 1
        var locX = x
        var locN = n
        if n < 0 {
            locX = 1 / locX
            locN = -locN
        }

        while locN != 0 {
            // 位运算判断奇偶
            if locN & 1 == 1 {
                pow = locX * pow
            }
            locX = locX * locX
            // 位运算除以2
            locN >>= 1
        }

        return pow
    }
}
```
> TESTING：leetcode
